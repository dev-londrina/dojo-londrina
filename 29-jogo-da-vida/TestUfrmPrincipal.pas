unit TestUfrmPrincipal;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  UJogoDaVida, TestFramework, System.SysUtils, Vcl.Graphics, Winapi.Windows, System.Variants,
  Vcl.Dialogs, Vcl.Controls, Vcl.Forms, Winapi.Messages, System.Classes, UfrmPrincipal;

type
  // Test methods for class TfrmPrincipal

  TestTfrmPrincipal = class(TTestCase)
  strict private
    FfrmPrincipal: TfrmPrincipal;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure Vazio;
    procedure UmaCelula;
    procedure UmaCelulaMorta;
    procedure DuasCelulasVivas;
    procedure UmaCelulaVivaUmaCelulaMorta;
    procedure TresVivas;
    procedure TresVivasDoisCiclos;

  end;

implementation

procedure TestTfrmPrincipal.Vazio;
  var Jogo: TJogoDaVida;
    arr: Tarr;
begin
  Jogo := TJogoDaVida.Create( arr );
  Jogo.ciclo;
  check(length(Jogo.estado) = 0, 'estado deve ser vazio');
end;

procedure TestTfrmPrincipal.UmaCelula;
  var Jogo: TJogoDaVida;
    arr: Tarr;
begin
  setlength(arr, 1);
  arr[0] := 'V';
  Jogo := TJogoDaVida.Create( arr );
  Jogo.ciclo;
  check(length(Jogo.estado) = 1, 'deve possuir uma celula');
  check(Jogo.estado[0] = 'M', 'celula deve estar morto');
end;

procedure TestTfrmPrincipal.UmaCelulaMorta;
  var Jogo: TJogoDaVida;
    arr: Tarr;
begin
  setlength(arr, 1);
  arr[0] := 'M';
  Jogo := TJogoDaVida.Create( arr );
  Jogo.ciclo;
  check(length(Jogo.estado) = 1, 'deve possuir uma celula');
  check(Jogo.estado[0] = 'M', 'celula deve estar morto');

end;

procedure TestTfrmPrincipal.UmaCelulaVivaUmaCelulaMorta;
var Jogo: TJogoDaVida;
    arr: Tarr;
begin
  setlength(arr, 2);
  arr := ['V','M'];
  Jogo := TJogoDaVida.Create( arr );
  Jogo.ciclo;
  check(length(Jogo.estado) = 2, 'deve possuir duas celula');
  check((Jogo.estado[0] = 'M') and (Jogo.estado[1] = 'M'), 'celulas devem estar mortas :(');
end;

procedure TestTfrmPrincipal.DuasCelulasVivas;
var Jogo: TJogoDaVida;
    arr: Tarr;
begin
  setlength(arr, 2);
  arr := ['V','V'];
  Jogo := TJogoDaVida.Create( arr );
  Jogo.ciclo;
  check(length(Jogo.estado) = 2, 'deve possuir duas celula');
  check((Jogo.estado[0] = 'M') and (Jogo.estado[1] = 'M'), 'celulas devem estar mortas :(');
end;

procedure TestTfrmPrincipal.TresVivas;
var Jogo: TJogoDaVida;
    arr: Tarr;
begin
  setlength(arr, 3);
  arr := ['V','V','V'];
  Jogo := TJogoDaVida.Create( arr );
  Jogo.ciclo;
  check(length(Jogo.estado) = 3, 'deve possuir tres celula');
  check((Jogo.estado[0] = 'M')
        and (Jogo.estado[1] = 'V')
        and (Jogo.estado[2] = 'M'),
        'celula do meio sobrevive :D');
end;

procedure TestTfrmPrincipal.TresVivasDoisCiclos;
var Jogo: TJogoDaVida;
    arr: Tarr;
begin
  setlength(arr, 3);
  arr := ['V','V','V'];
  Jogo := TJogoDaVida.Create( arr );
  Jogo.ciclo;
  Jogo.ciclo;
  check(length(Jogo.estado) = 3, 'deve possuir tres celulas');
  check((Jogo.estado[0] = 'M')
        and (Jogo.estado[1] = 'M')
        and (Jogo.estado[2] = 'M'),
        'nenhuma sobrevive :(');
end;


procedure TestTfrmPrincipal.SetUp;
begin
  //FfrmPrincipal := TfrmPrincipal.Create;
end;

procedure TestTfrmPrincipal.TearDown;
begin
//  FfrmPrincipal.Free;
//  FfrmPrincipal := nil;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTfrmPrincipal.Suite);
end.

